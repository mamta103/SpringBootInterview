
1.@Configuration::


2.What is the difference between SIT and UAT?

SIT->System Intregration Testing
UAT->USer Acceptence Testing
both above belongs to functional testing.System Integration Testing (SIT) ensures that individual modules, product set-ups, batch operations, basic reporting functionalities and key interfaces of an application-under-test (AUT) work well.

3.AD Environment:: Active Directy

4.A GAP:: GAP analysis is a method of assessing the differences in performance between a business' information systems or software applications to determine whether business requirements are being met and, if not, what steps should be taken to ensure they are met successfully.

Gap refers to the space between "where we are" (the present state) and "where we want to be" (the target state). A gap analysis may also be referred to as a needs analysis, needs assessment or need-gap analysis. 

5.SSO is a solution that allows one sign on, obviously. For example, I've had (many years)of experience using ClearTrust in conjunction with RSA Secur-Id as a very secure SSO solution.

Single sign-on (SSO) is a session and user authentication service that permits a user to use one set of login credentials (e.g., name and password) to access multiple applications. ... On the back end, SSO is helpful for logging user activities as well as monitoring user accounts

ClearTrust (now called RSA Access Manager) is a SSO solution that works very well with web apps, since it's a web-based solution, and it supports multiple types of authentication (AD, userid/password, SecurId, certificates) and also works with about any OS or web server you can think of.

6.Active Directory Federation Services (ADFS) is a Single Sign-On (SSO) solution created by Microsoft. As a component of Windows Server operating systems, it provides users with authenticated access to applications that are not capable of using Integrated Windows Authentication (IWA) through Active Directory (AD).
Active Directory Federation Services (ADFS) is a standards-based web Single Sign-On federated identity which implements claims based authentication across forests.ADFS provides authentication services for applications over standard protocols. We typically refer to these apps as claims based applications. Claims based authentication is the process of authenticating a user based on a set of claims about its identity contained in a trusted token. Such a token is often issued and signed by an entity that is able to authenticate the user by other means, and that is trusted by the entity doing the claims based authentication. Claims are essentially attributes derived from Active Directory, a LDAP or SQL server.

In ADFS, identity federation is established between two organizations by establishing trust between two security realms. A federation server on one side (the Accounts side) authenticates the user through the standard means in Active Directory Domain Services and then issues a token containing a series of claims about the user, including its identity.

On the other side, the Resources side, another federation server validates the token and issues another token for the local servers to accept the claimed identity. This allows a system to provide controlled access to its resources or services to a user that belongs to another security realm without requiring the user to authenticate directly to the system and without the two systems sharing a database of user identities or passwords.


7.GTI:: Industry Standard

8.What is the Big Difference Between SAML and OAuth? ... SAML (Security Assertion Markup Language) is an umbrella standard that encompasses profiles, bindings and constructs to achieve Single Sign On (SSO), Federation and Identity Management. OAuth (Open Authorization) is a standard for authorization of resources.


9.What is <scope> under <dependency> in pom.xml for?
The <scope> element can take 6 values: compile, provided, runtime, test, system and import.

This scope is used to limit the transitivity of a dependency, and also to affect the classpath used for various build tasks.

compile

This is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects.

provided

This is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive.

runtime

This scope indicates that the dependency is not required for compilation, but is for execution. It is in the runtime and test classpaths, but not the compile classpath.

test

This scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases.

system

This scope is similar to provided except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository.

import (only available in Maven 2.0.9 or later)

This scope is only used on a dependency of type pom in the section. It indicates that the specified POM should be replaced with the dependencies in that POM's section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.

10.SAML SSO works by transferring the user's identity from one place (the identity provider) to another (the service provider). This is done through an exchange of digitally signed XML documents. Consider the following scenario: A user is logged into a system that acts as an identity provider.
Security Assertion Markup Language 2.0 (SAML 2.0) is a standard providing means to exchange authentication and authorization data between security domains. It is typically used to achieve cross-domain single sign-on (SSO) and creation of security tokens.

Security Assertion Markup Language (saml) is an xml-based open standard for exchanging authentication and authorization data between security domains, that is, between an identity provider (a producer of assertions) and a service provider (a consumer of assertions). saml is a product of the oasis Security Services Technical Committee.
SAML version 2 (saml-2.0) adds digital signatures and resolves back into the SAML standard enhancements made to the SAML 1.1 (saml-1.1) specification by other systems (for instance Shibboleth and WS-federation).

SAML 2.0 is significantly different from SAML 1.1 and is not backwards compatible, although many systems can handle both.


11.Implementing ADFS in application how to?
My personal situation is that the application (SP) is hosted on AWS (hosting only) and the IDP is a third party organisation which implements Active Directory. I think I have the theory worked out, like:

-the browser tries to access the SP
-the SP sends an authentication request to the IDP
-the IDP authenticates the user (the user physically signs in)
-an authentication authorization token is sent from the IDP to the SP 
-the user can use the application

You don't implement ADFS in the application. ADFS is a separate IDP.

What language is your SP written in?

"IDP is a third party organisation which implements Active Directory" Is this the ADFS instance or something else? In which case, where does ADFS fit in?

What you need is a SAML stack on the SP (this is where where Spring Security comes in).

Spring Security provides federation metadata. This describes SAML endpoints, certificates etc.

You then import this metadata file into ADFS as a SAML SP.

You then configure claims rules for the AD attributes you want to send to your SP.

That's basically it!

1.@PathVariable("id")

2.@RequestBody : If a method parameter is annotated with @RequestBody, Spring will bind the incoming HTTP request body(for the URL mentioned in @RequestMapping for that method) to that parameter. While doing that, Spring will [behind the scenes] use HTTP Message converters to convert the HTTP request body into domain object [deserialize request body to domain object], based on ACCEPT or Content-Type header present in request.

3.ResponseEntity is a real deal. It represents the entire HTTP response. Good thing about it is that you can control anything that goes into it. You can specify status code, headers, and body. It comes with several constructors to carry the information you want to sent in HTTP Response.

4.@RestController : First of all, we are using Spring 4’s new @RestController annotation. This annotation eliminates the need of annotating each method with @ResponseBody. Under the hood, @RestController is itself annotated with @ResponseBody, and can be considered as combination of @Controller and @ResponseBody.

5.@ResponseBody : If a method is annotated with @ResponseBody, Spring will bind the return value to outgoing HTTP response body. While doing that, Spring will [behind the scenes] use HTTP Message converters to convert the return value to HTTP response body [serialize the object to response body], based on Content-Type present in request HTTP header. As already mentioned, in Spring 4, you may stop using this annotation.

6.@PathVariable This annotation indicates that a method parameter should be bound to a URI template variable [the one in ‘{}’].

7.MediaType : With @RequestMapping annotation, you can additionally, specify the MediaType to be produced or consumed (using produces or consumes attributes) by that particular controller method, to further narrow down the mapping.


8.Spring’s RestTemplate comes to Rescue. RestTemplate provides higher level methods that correspond to each of the six main HTTP methods that make invoking many RESTful services a one-liner and enforce REST best practices.

HTTP Methods and corresponding RestTemplate methods:

HTTP GET : getForObject, getForEntity
HTTP PUT : put(String url, Object request, String…​urlVariables)
HTTP DELETE : delete
HTTP POST : postForLocation(String url, Object request, String…​ urlVariables), postForObject(String url, Object request, Class responseType, String…​ uriVariables)
HTTP HEAD : headForHeaders(String url, String…​ urlVariables)
HTTP OPTIONS : optionsForAllow(String url, String…​ urlVariables)
HTTP PATCH and others : exchange execute

9.How to suppress unchecked warnings – Java
The ‘unchecked warnings’ is quite popular warning message in Java. However, if you insist this is an invalid warning, and there are no ways to solve it without compromising the existing program functionality. You may just use @SuppressWarnings(“unchecked”) to suppress unchecked warnings in Java.

1. In Class
If applied to class level, all the methods and members in this class will ignore the unchecked warnings message.

@SuppressWarnings("unchecked")
public class classA{...}


2. In Method
If applied to method level, only this method will ignore the unchecked warnings message.
@SuppressWarnings("unchecked")
private void method1(){...}


3.3. In Property
If applied to property level, only this property will ignore the unchecked warnings message.
@SuppressWarnings("unchecked")
private List list1;


10.Spring @Component, @Service, @Repository, @Controller Difference
Spring @Component, @Service, @Repository and @Controller annotations are used for automatic bean detection using classpath scan in Spring framework. 

 @Component is a generic annotation. 
 Difference of @Service, @Repository, @Controller with @Component is they are special cases of @Component and used for particular purposes. 

Spring automatically scans and identifies all these classes that are annotated with “ @Component, @Service, @Repository, @Controller”  and registers BeanDefinition with ApplicationContext.

@Component – generic and can be used across application.
@Service – annotate classes at service layer level.
@Controller – annotate classes at presentation layers level, mainly used in Spring MVC.
@Repository – annotate classes at persistence layer, which will act as database repository.











